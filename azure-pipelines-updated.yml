# Azure Pipelines RELEASE Pipeline for COA MCP Framework
# Manual trigger only - publishes to Azure Artifacts and NuGet.org
# For CI builds, use azure-pipelines.yml

name: 'COA MCP Framework - RELEASE - v$(majorVersion).$(minorVersion).$(patchVersion)'

# MANUAL TRIGGER ONLY - No automatic triggers
trigger: none

# Don't run on pull requests
pr: none

# Parameters for manual runs
parameters:
  - name: publishToNuGet
    displayName: 'Publish to NuGet.org?'
    type: boolean
    default: false
  - name: createGitTag
    displayName: 'Create Git tag for release?'
    type: boolean
    default: true

pool:
  name: "Default" # Using local Windows agent pool

variables:
  buildConfiguration: "Release"
  dotnetSdkVersion: "9.x"
  # Base version for Framework packages - v1.1.0
  majorVersion: 1
  minorVersion: 1
  # Auto-incrementing patch version - increments on every build
  # The counter is keyed by major.minor version, so it resets when those change
  patchVersion: $[counter(format('{0}.{1}', variables['majorVersion'], variables['minorVersion']), 0)]
  versionPrefix: "$(majorVersion).$(minorVersion).$(patchVersion)"
  versionSuffix: ""
  # Protocol package version - separate versioning to maintain compatibility
  protocolMajorVersion: 1
  protocolMinorVersion: 3
  # Use a separate counter for protocol to continue from existing version
  protocolPatchVersion: $[counter(format('protocol-{0}.{1}', variables['protocolMajorVersion'], variables['protocolMinorVersion']), 178)]
  protocolVersion: "$(protocolMajorVersion).$(protocolMinorVersion).$(protocolPatchVersion)"
  # Windows-specific settings
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true
  NUGET_PACKAGES: $(Pipeline.Workspace)\.nuget\packages
  # Manual run parameters
  shouldPublishToNuGet: ${{ parameters.publishToNuGet }}
  shouldCreateTag: ${{ parameters.createGitTag }}
  # Always treat manual runs as releases
  isRelease: true

stages:
  - stage: Build
    displayName: "Build and Test"
    jobs:
      - job: BuildAndTest
        displayName: "Build, Test, and Pack"
        steps:
          - checkout: self
            fetchDepth: 0
            clean: true

          - powershell: |
              Write-Host "Agent Information:"
              Write-Host "=================="
              Write-Host "Agent Name: $env:AGENT_NAME"
              Write-Host "Agent OS: $env:AGENT_OS"
              Write-Host "Agent Version: $env:AGENT_VERSION"
              Write-Host "OS Version: $([System.Environment]::OSVersion.VersionString)"
              Write-Host "PowerShell Version: $($PSVersionTable.PSVersion)"
              Write-Host "=================="
            displayName: "Display agent information"

          - task: Cache@2
            displayName: "Cache NuGet packages"
            inputs:
              key: 'nuget | "$(Agent.OS)" | **/*.csproj,!**/bin/**,!**/obj/**'
              restoreKeys: |
                nuget | "$(Agent.OS)"
                nuget
              path: "$(NUGET_PACKAGES)"

          - powershell: |
              # Calculate version based on branch/tag
              $majorVersion = $(majorVersion)
              $minorVersion = $(minorVersion)
              $patchVersion = $(patchVersion)

              # Get the build counter for the current version
              $buildRevision = $env:BUILD_BUILDNUMBER.Split('.')[-1]

              Write-Host "Build Source Branch: $env:BUILD_SOURCEBRANCH"
              Write-Host "Build Reason: $env:BUILD_REASON"
              Write-Host "Patch Version (auto-incremented): $patchVersion"

              if ($env:BUILD_SOURCEBRANCH -match "^refs/tags/v(.*)") {
                  # Tag build - use the version from the tag
                  $version = $matches[1]
                  $versionSuffix = ""
                  Write-Host "Tag build detected. Version from tag: $version"
              }
              elseif ($env:BUILD_SOURCEBRANCH -eq "refs/heads/main") {
                  # Main branch - use auto-incremented patch version
                  $version = "$majorVersion.$minorVersion.$patchVersion"
                  $versionSuffix = ""
                  Write-Host "Main branch build. Version: $version"
              }
              elseif ($env:BUILD_SOURCEBRANCH -match "^refs/heads/release/(.*)") {
                  # Release branch
                  $releaseName = $matches[1]
                  if ($releaseName -match "^(\d+)\.(\d+)") {
                      $majorVersion = $matches[1]
                      $minorVersion = $matches[2]
                  }
                  $version = "$majorVersion.$minorVersion.$patchVersion"
                  $versionSuffix = "rc.$buildRevision"
                  Write-Host "Release branch build. Version: $version-$versionSuffix"
              }
              elseif ($env:BUILD_SOURCEBRANCH -eq "refs/heads/develop") {
                  # Develop branch - preview versions
                  $version = "$majorVersion.$minorVersion.$patchVersion"
                  $versionSuffix = "preview.$buildRevision"
                  Write-Host "Develop branch build. Version: $version-$versionSuffix"
              }
              else {
                  # Feature branches or PRs
                  $version = "$majorVersion.$minorVersion.$patchVersion"
                  $branchName = $env:BUILD_SOURCEBRANCHNAME -replace '[^a-zA-Z0-9]', ''
                  $versionSuffix = "alpha.$branchName.$buildRevision"
                  Write-Host "Feature branch build. Version: $version-$versionSuffix"
              }

              # Set pipeline variables
              Write-Host "##vso[task.setvariable variable=versionPrefix]$version"
              Write-Host "##vso[task.setvariable variable=versionSuffix]$versionSuffix"

              if ($versionSuffix) {
                  Write-Host "##vso[build.updatebuildnumber]$version-$versionSuffix"
                  Write-Host "Final version: $version-$versionSuffix"
              }
              else {
                  Write-Host "##vso[build.updatebuildnumber]$version"
                  Write-Host "Final version: $version"
              }
            displayName: "Calculate version number"
            name: VersionStep

          - powershell: |
              Write-Host "========================================="
              Write-Host "Package Version Information:"
              Write-Host "========================================="
              Write-Host "Framework Packages:"
              Write-Host "  Major Version: $(majorVersion)"
              Write-Host "  Minor Version: $(minorVersion)"
              Write-Host "  Patch Version: $(patchVersion)"
              Write-Host "  Version Prefix: $(versionPrefix)"
              Write-Host "  Version Suffix: $(versionSuffix)"
              if ("$(versionSuffix)") {
                  Write-Host "  Full Version: $(versionPrefix)-$(versionSuffix)"
              }
              else {
                  Write-Host "  Full Version: $(versionPrefix)"
              }
              Write-Host "  Counter Key: $(majorVersion).$(minorVersion)"
              Write-Host "-----------------------------------------"
              Write-Host "Protocol Package:"
              Write-Host "  Protocol Version: $(protocolVersion)"
              Write-Host "  Counter Key: protocol-$(protocolMajorVersion).$(protocolMinorVersion)"
              Write-Host "========================================="
            displayName: "Display version information"

          - task: UseDotNet@2
            displayName: "Install .NET SDK"
            inputs:
              version: $(dotnetSdkVersion)
              includePreviewVersions: false

          - task: DotNetCoreCLI@2
            displayName: "Restore packages"
            inputs:
              command: "restore"
              projects: |
                **/*.csproj
                !**/templates/**/*.csproj
              feedsToUse: "select"
              vstsFeed: "COA"
              includeNuGetOrg: true

          - powershell: |
              # Prepare build/pack arguments based on version suffix
              $versionArgs = "-p:VersionPrefix=$(versionPrefix)"
              if ("$(versionSuffix)") {
                  $versionArgs += " -p:VersionSuffix=$(versionSuffix)"
              }
              Write-Host "##vso[task.setvariable variable=versionArguments]$versionArgs"
              Write-Host "Version arguments: $versionArgs"
            displayName: "Prepare version arguments"

          - task: DotNetCoreCLI@2
            displayName: "Build solution"
            inputs:
              command: "build"
              projects: "COA.Mcp.Framework.sln"
              arguments: "--configuration $(buildConfiguration) --no-restore $(versionArguments)"

          - task: DotNetCoreCLI@2
            displayName: "Run tests"
            inputs:
              command: "test"
              projects: |
                **/*Tests.csproj
                !**/templates/**/*Tests.csproj
              arguments: '--configuration $(buildConfiguration) --no-build --collect:"XPlat Code Coverage"'
              publishTestResults: true

          - task: PublishCodeCoverageResults@2
            displayName: "Publish code coverage"
            inputs:
              summaryFileLocation: '$(Agent.TempDirectory)\**\coverage.cobertura.xml'

          # Pack Protocol (using separate versioning)
          - task: DotNetCoreCLI@2
            displayName: "Pack COA.Mcp.Protocol"
            inputs:
              command: "pack"
              packagesToPack: "src/COA.Mcp.Protocol/COA.Mcp.Protocol.csproj"
              configuration: $(buildConfiguration)
              packDirectory: "$(Build.ArtifactStagingDirectory)/packages"
              nobuild: true
              versioningScheme: "off"
              arguments: "-p:VersionPrefix=$(protocolVersion) --no-restore"

          # Pack Core Framework
          - task: DotNetCoreCLI@2
            displayName: "Pack COA.Mcp.Framework"
            inputs:
              command: "pack"
              packagesToPack: "src/COA.Mcp.Framework/COA.Mcp.Framework.csproj"
              configuration: $(buildConfiguration)
              packDirectory: "$(Build.ArtifactStagingDirectory)/packages"
              nobuild: true
              versioningScheme: "off"
              arguments: "$(versionArguments) --no-restore"

          # Pack Token Optimization
          - task: DotNetCoreCLI@2
            displayName: "Pack COA.Mcp.Framework.TokenOptimization"
            inputs:
              command: "pack"
              packagesToPack: "src/COA.Mcp.Framework.TokenOptimization/COA.Mcp.Framework.TokenOptimization.csproj"
              configuration: $(buildConfiguration)
              packDirectory: "$(Build.ArtifactStagingDirectory)/packages"
              nobuild: true
              versioningScheme: "off"
              arguments: "$(versionArguments) --no-restore"

          # Pack Testing Framework
          - task: DotNetCoreCLI@2
            displayName: "Pack COA.Mcp.Framework.Testing"
            inputs:
              command: "pack"
              packagesToPack: "src/COA.Mcp.Framework.Testing/COA.Mcp.Framework.Testing.csproj"
              configuration: $(buildConfiguration)
              packDirectory: "$(Build.ArtifactStagingDirectory)/packages"
              nobuild: true
              versioningScheme: "off"
              arguments: "$(versionArguments) --no-restore"

          # Pack Templates
          - task: DotNetCoreCLI@2
            displayName: "Pack COA.Mcp.Framework.Templates"
            inputs:
              command: "pack"
              packagesToPack: "src/COA.Mcp.Framework.Templates/COA.Mcp.Framework.Templates.csproj"
              configuration: $(buildConfiguration)
              packDirectory: "$(Build.ArtifactStagingDirectory)/packages"
              nobuild: true
              versioningScheme: "off"
              arguments: "$(versionArguments) --no-restore"

          # Pack Migration Tool
          - task: DotNetCoreCLI@2
            displayName: "Pack COA.Mcp.Framework.Migration"
            inputs:
              command: "pack"
              packagesToPack: "src/COA.Mcp.Framework.Migration/COA.Mcp.Framework.Migration.csproj"
              configuration: $(buildConfiguration)
              packDirectory: "$(Build.ArtifactStagingDirectory)/packages"
              nobuild: true
              versioningScheme: "off"
              arguments: "$(versionArguments) --no-restore"

          # Pack Client Library
          - task: DotNetCoreCLI@2
            displayName: "Pack COA.Mcp.Client"
            inputs:
              command: "pack"
              packagesToPack: "src/COA.Mcp.Client/COA.Mcp.Client.csproj"
              configuration: $(buildConfiguration)
              packDirectory: "$(Build.ArtifactStagingDirectory)/packages"
              nobuild: true
              versioningScheme: "off"
              arguments: "$(versionArguments) --no-restore"

          - powershell: |
              Write-Host "Generated NuGet packages:"
              Write-Host "========================="
              Get-ChildItem -Path "$(Build.ArtifactStagingDirectory)\packages" -Filter "*.nupkg" | ForEach-Object {
                  Write-Host "$($_.Name) - Size: $([math]::Round($_.Length / 1MB, 2)) MB"
              }
              Write-Host "========================="
            displayName: "List generated packages"

          - task: PublishBuildArtifacts@1
            displayName: "Publish artifacts"
            inputs:
              PathtoPublish: '$(Build.ArtifactStagingDirectory)\packages'
              ArtifactName: "packages"
              publishLocation: "Container"

  - stage: PublishInternal
    displayName: "Publish to Azure DevOps"
    dependsOn: Build
    condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))
    jobs:
      - job: PublishToAzureDevOps
        displayName: "Publish to COA Feed"
        steps:
          - task: DownloadBuildArtifacts@1
            displayName: "Download artifacts"
            inputs:
              buildType: "current"
              downloadType: "single"
              artifactName: "packages"
              downloadPath: "$(System.ArtifactsDirectory)"

          - task: NuGetCommand@2
            displayName: "Push packages to COA Azure DevOps feed"
            inputs:
              command: 'push'
              packagesToPush: '$(System.ArtifactsDirectory)/packages/*.nupkg'
              nuGetFeedType: 'internal'
              publishVstsFeed: 'COA'
              allowPackageConflicts: true

  - stage: PublishNuGetOrg
    displayName: "Publish to NuGet.org"
    dependsOn: PublishInternal
    condition: and(succeeded(), eq(variables['shouldPublishToNuGet'], 'true'))
    jobs:
      - job: PublishToNuGetOrg
        displayName: "Publish to NuGet.org"
        steps:
          - task: DownloadBuildArtifacts@1
            displayName: "Download artifacts"
            inputs:
              buildType: "current"
              downloadType: "single"
              artifactName: "packages"
              downloadPath: "$(System.ArtifactsDirectory)"

          - powershell: |
              Write-Host "Packages to publish to NuGet.org:"
              Write-Host "================================="
              Get-ChildItem -Path "$(System.ArtifactsDirectory)\packages" -Filter "*.nupkg" | ForEach-Object {
                  Write-Host $_.Name
              }
              Write-Host "================================="
            displayName: "List packages to publish"

          - task: NuGetCommand@2
            displayName: "Push COA.Mcp.Framework to NuGet.org"
            inputs:
              command: 'push'
              packagesToPush: '$(System.ArtifactsDirectory)/packages/COA.Mcp.Framework.*.nupkg'
              nuGetFeedType: 'external'
              publishFeedCredentials: 'NuGetOrg-ServiceConnection'
              verbosityPush: 'Detailed'

          - task: NuGetCommand@2
            displayName: "Push COA.Mcp.Framework.TokenOptimization to NuGet.org"
            inputs:
              command: 'push'
              packagesToPush: '$(System.ArtifactsDirectory)/packages/COA.Mcp.Framework.TokenOptimization.*.nupkg'
              nuGetFeedType: 'external'
              publishFeedCredentials: 'NuGetOrg-ServiceConnection'
              verbosityPush: 'Detailed'

          - task: NuGetCommand@2
            displayName: "Push COA.Mcp.Framework.Testing to NuGet.org"
            inputs:
              command: 'push'
              packagesToPush: '$(System.ArtifactsDirectory)/packages/COA.Mcp.Framework.Testing.*.nupkg'
              nuGetFeedType: 'external'
              publishFeedCredentials: 'NuGetOrg-ServiceConnection'
              verbosityPush: 'Detailed'

          - task: NuGetCommand@2
            displayName: "Push COA.Mcp.Framework.Templates to NuGet.org"
            inputs:
              command: 'push'
              packagesToPush: '$(System.ArtifactsDirectory)/packages/COA.Mcp.Framework.Templates.*.nupkg'
              nuGetFeedType: 'external'
              publishFeedCredentials: 'NuGetOrg-ServiceConnection'
              verbosityPush: 'Detailed'

              verbosityPush: 'Detailed'

          - task: NuGetCommand@2
            displayName: "Push COA.Mcp.Framework.Migration to NuGet.org"
            inputs:
              command: 'push'
              packagesToPush: '$(System.ArtifactsDirectory)/packages/COA.Mcp.Framework.Migration.*.nupkg'
              nuGetFeedType: 'external'
              publishFeedCredentials: 'NuGetOrg-ServiceConnection'
              verbosityPush: 'Detailed'

          - task: NuGetCommand@2
            displayName: "Push COA.Mcp.Client to NuGet.org"
            inputs:
              command: 'push'
              packagesToPush: '$(System.ArtifactsDirectory)/packages/COA.Mcp.Client.*.nupkg'
              nuGetFeedType: 'external'
              publishFeedCredentials: 'NuGetOrg-ServiceConnection'
              verbosityPush: 'Detailed'

          - powershell: |
              Write-Host "Successfully published packages to NuGet.org!"
              Write-Host "Packages should appear at https://www.nuget.org shortly"
            displayName: "Publish success message"